# java



- sysout 느리대요 => StringBuilder나 BufferedWriter 사용

- BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  
  - 입력 받을때
- StringTokenizer st = new StringTokenizer(br.readLine(), " ");
  - 입력받은거 잘라서 읽을 때
  - st.nextToken()으로 다음거 받아옴
- Integer.parseInt(String)
  
  - 숫자형의 문자열을 인자 값으로 받으면 해당 값을 10진수의 int 형으로 반환해줌
- Arrays.fill(arr, value)
  
  - arr배열 value값으로 초기화
- charAt(Index)
  
  - 문자열 중에 인덱스 위치에 해당하는 문자 추출
  
  







---

wirte once, run anywhere는 자바의 어떤 특징? 

자바가 어떤 장비에서도 개발되고 표전 바이트코드(자바언어 컴파일하면 바이트코드 됨) 컴파일되고 실행될 수 있음

##### 자바 네임룰

- 클래스, 인터페이스 => 파스칼 (첫자도 대문자), 명사
- 메소드 =>  카멜(첫자 소문자, 다음단어부터 대문자), 동사
- 변수 => 카멜
- 상수 => 모두 대문자
- 패키지 => 모두 소문자

##### 변수 타입에 따른 구분

- 기본형 (8개)
  - byte, short, int, long, float, double, char, boolean

- 참조형 (그 외, 첫문자 대문자)

##### 변수 위치에 따른 구분

- 멤버변수 (fileld)
  - 메서드 밖에 선언
  - static이 붙은 변수: 클래스 변수
  - static이 붙지 않은 변수: 인스턴스 변수

- 지역변수( local)
  - 메서드 안에 선언
- 차이점
  - 지역변수는 메서드 내에서만 사용 가능
  - 멤버변수는 값의 자동 초기화가 되지만, 지역 변수는 값의 자동 초기화가 되지 않음
  - 멤버변수의 값의 자동 초기화: 정수=0, 실수=0.0, 문자=' ', 논리=false, <u>**참조: null**</u>

##### 형변환

- byte -> short -> int -> long -> float -> double
- ​             char   -> int -> long -> float -> double
- <u>산술연산(+, -, *, /)을 할 때 byte, short, char, int의 연산은 int로 변환 후 연산함</u>

- int 보다 큰 타입의 산술연산은 큰 타입으로 변환 후 연산함

- 숫자에 F or f, L or l, D or d 붙으면 형변환 해주는거

```java
double d = 5 / 2;
System.out.println(d);  // 2
d = 5 / 2d;
System.out.println(d);  // 2.5
double d3 = (double)(5 / 2);
System.out.println(d3); // 2.0
```

```java
int price = 10 * 500;
if (price >= 1000){
    //price = price * 0.9; 에러남, int형에 더 큰 자료형 담으려해서
    price = (int)(price * 0.9);	// 이래주면 소수점 자르고 가능
    price *= 0.9;				// 배정 연산자는 형변환 자동을 처리!!
}
```

##### 배열 선언

```java
int[] arr = new int[3];				//int arr[] = new int[] 도 가능, 크기 필수
int[] arr = {1, 2, 3};				//선언시만 가능
int[] arr = new int[] {1, 2, 3};	
```

- 세 번째 선언은 언제 쓸까요? 보통 한번만 사용하는 것을 변수로 지정하지 않고 바로 사용하는데,  예를들어 저 arr가 인수로 쓰이는데 한번만 쓰여서 선언하면서 초기화 해줄 때
- 배열은 자동 초기화 됨!

##### 배열 요소 확인 tip

```java
Arrays.toString(arr);
// 다차원 배열
Arrays.deepToString(arr);
```

##### 메모리

```java
int[][] arr = new int[3][2]		//선언시
```

![image-20210120093232661](C:\Users\20131\AppData\Roaming\Typora\typora-user-images\image-20210120093232661.png)

- 이런식으로 그려짐, arr[3]이 가리키는 배열안에는 0으로 자동초기화 되어있음

```java
String[] arr2 = new String[3];
System.out.println(arr[0].length());
```

- 이러면 어떻게 될까? 메모리 그려보고 뭐 출력될지 생각해보기

![image-20210120095442708](C:\Users\20131\AppData\Roaming\Typora\typora-user-images\image-20210120095442708.png)

- String은 참조형이므로 초기값 null을 가짐, 즉 arr2[0]으로 가서 String으로 된 곳을 가보면 null값이 들어가있음. 그래서 에러뜸

```java
Bread b1 = new Bread() 	//new 인스턴스 생성, new 다음에는 참조형 와야함(기본형x)
Bread b3 = b1; 			//이러면 b1을 가리키는게 아니라 b1이 가리키는 곳을 가리킴!
```



##### 문자열 특징

- string constant pull로 중복되는거 한번만

```
String s = "1";
String s2 = "1";
```

![image-20210120104238061](C:\Users\20131\AppData\Roaming\Typora\typora-user-images\image-20210120104238061.png)

- 이렇게 하면 같은 주소 가리킴
- 근데!!! 파이썬에선 같은 주소 가리켰을때 s 바꾸면 s2도 바뀌고 했잖아, 근데 자바 문자열에서 s += "2"; 했을 때 s, s2가 가리는 값이 바뀌는게 아니라, "12"를 표현하는 주소가 새로 생김! 
- 그래서 자바에서 append기능이 있으면 String 쓰지 말래, => StringBuilder로 대체 가능

##### 메소드 기능은 최소한으로!(하나만)

```java
// 간단한 프로그램인데 이걸 이쁘게 바꿔줄거임
import java.util.Scanner;
public class Test04_1 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Bread[] breadArr = new Bread[3];
		int pos = 0;
		
		outer:		//이러면 outer가 while문의 이름이 됨
		while(true) {
			System.out.println("-------------------");
			System.out.println("1. 전체보기");
			System.out.println("2. 등록");
			System.out.println("0. 종료");
			System.out.println("-------------------");
			System.out.print("선택 : ");
			int choice = sc.nextInt();
			sc.nextLine();		//한줄 읽어서 줄넘김 문자 읽어서 빼고 줌, br.readLine()도 한줄 읽는데 줄넘김 빼고! B형 BufferedReader 직접 만들어야한대
			//그래서 그냥 int choice = Integer.parseInt(sc.nextLine()); 이러면 됨
			switch(choice){
				case 1: 
					System.out.println("빵 정보 조회하기");
					for(int i = 0; i < pos; i++){
						Bread b = breadArr[i];
						System.out.println(b.name +", " + b.price);
					}
					if(pos == 0) {
						System.out.println("등록된 빵 정보가 없습니다.");
					}
					break;
				case 2:
					System.out.println("빵 정보 등록");
					System.out.print("이름 : ");
					String name = sc.nextLine();
					System.out.print("가격 : ");
					int price = Integer.parseInt(sc.nextLine());
					Bread b = new Bread();
					b.name = name;
					b.price = price;
					breadArr[pos++] = b;
					System.out.println("빵이 등록 되었습니다.");
					break;
				case 0: 
					System.out.println("종료 합니다.");
					break outer;		//이런식으로도 가능 아님 그냥 return 해줘도 됨 or System.exit(0); 강제 종료
			}
		}
	}
}
```

```java
public class Test04_2 {
	public static void main(String[] args) {
		BreadService04_2 t = new BreadService04_2();
		t.execute();
	}
}
import java.util.Arrays;
import java.util.Scanner;

public class BreadService04_2 {
	static Scanner sc = new Scanner(System.in);
	static Bread[] breadArr = new Bread[1];
	static int pos = 0;

	// void a(){ execute()}; 이래도 됨 new없이 같은곳은 그냥 접근 가능
	void execute() {
//		outer:		//이러면 outer가 while문의 이름이 됨
		while (true) {
			int choice = choiceMenu();
			switch (choice) {
			case 1:
				list();
				break;
			case 2:
				regist();
				break;
			case 0:
				exit();
			}
		}
	}

	int choiceMenu() {
		System.out.println("-------------------");
		System.out.println("1. 전체보기");
		System.out.println("2. 등록");
		System.out.println("0. 종료");
		System.out.println("-------------------");
		System.out.print("선택 : ");
		int choice = sc.nextInt();
		sc.nextLine(); // 한줄 읽어서 줄넘김 문자 읽어서 빼고 줌, br.readLine()도 한줄 읽는데 줄넘김 빼고! B형 BufferedReader 직접
						// 만들어야한대
		// 그래서 그냥 int choice = Integer.parseInt(sc.nextLine()); 이러면 됨
		return choice;
	}

	void list() {
		System.out.println("빵 정보 조회하기");
		for (int i = 0; i < pos; i++) {
			Bread b = breadArr[i];
			System.out.println(b.name + ", " + b.price);
		}
		if (pos == 0) {
			System.out.println("등록된 빵 정보가 없습니다.");
		}

	}

	/*
	 * void regist() { System.out.println("빵 정보 등록"); System.out.print("이름 : ");
	 * String name = sc.nextLine(); System.out.print("가격 : "); int price =
	 * Integer.parseInt(sc.nextLine()); Bread b = new Bread(); b.name = name;
	 * b.price = price; breadArr[pos++] = b; System.out.println("빵이 등록 되었습니다."); }
	 */
	// 배열 크기 꽉 찼을 때 자동 증가
	void regist() {
		if (pos == breadArr.length) {
		
			// 1. 배열 새롭게 확장 생성
//			Bread[] temp = new Bread[pos * 2];
			// 2. 배열 복사
			/*직접 복사
			for (int i = 0; i < pos; i++) {
				temp[i] = breadArr[i];
			} */
			// API 활용
//			System.arraycopy(breadArr, 0, temp, 0, pos);	//원본, 원본시작위치(복사해줄 시작 위치), 목적, 목적시작위치(받을 시작위치), 길이
			
			// 3. 배열 참조 주소 변경
//			breadArr = temp;
			
			//기냥 이거로 한번에도 가능(배열의 생성과 복사를 동시에)
			breadArr = Arrays.copyOf(breadArr, pos*2);
		}
		System.out.println("빵 정보 등록");
		System.out.print("이름 : ");
		String name = sc.nextLine();
		System.out.print("가격 : ");
		int price = Integer.parseInt(sc.nextLine());
		Bread b = new Bread();
		b.name = name;
		b.price = price;
		breadArr[pos++] = b;
		System.out.println("빵이 등록 되었습니다.");
	}

	void exit() {
		System.out.println("종료 합니다.");
		System.exit(0);
//		break outer;		//이런식으로도 가능 아님 그냥 return 해줘도 됨 or System.exit(0); 강제 종료
	}
}
```

##### setter, getter, 생성자, 오버로딩, 체이닝(순서대로 찾아보면 됨)

```java
// Test.java

public class Test01 {
	public static void main(String[] args) {
		Member m = new Member();
//		m.name = "홍길동";
//		m.email = "123";
//		m.id = "hong";
		
		m.setId("hong");
		m.setEmail("123");
		m.setName("홍길동");
		
		//Ex. StringBuffer ==> 체이닝, 자기자신 뱉어서 한번에 알려줄 수 있도록
		/*
		 * 체이닝처럼 바꿔쓸 수 있음
		 * m.setId("hong")
		 *  .setEmail("123")
		 *  .setName("홍길동");
		 * 
		 * 세터 가서
		 * public Member setName(String name){
		 * 	this.name = name;
		 *  return this;
		 *  }
		 * 이런식으로 자기 자신 return하게 바꿔줘야함
		 */
		
		Dog d = new Dog();
//		Dog d2 = new Dog(100); 이 형태를 만족하는 생성자 없음, 이거 쓸라면 정수값 받는 생성자 만들어야함, 근데 만들어주면 그 위에게 에러남 생성자 있어서 기본생성자 제공안해주기 때문
		
		
		
		/*
		// 생성자 사용해서 
		Member m = new Member("hong", "123", "홍길동");
		// 생성자에 기본값 주어서 정보 다 안줘도 되도록
		Member m2 = new Member();
		*/
		System.out.println(m.getId());
		System.out.println(m.getEmail());
	}
}
```

```java
// Member.java
/*
 * 오버로딩
 * - 필수 : 메서드 이름이 동일하고 파라미터는 서도 달라야 한다.(개수 or 타입) 
 * - 나머지는 don't care!
 * 
 * this는 인스턴스 메서드의 첫번째 파라미터로 지정되어 있다(히든변수)
 * - static 영역에서는 this의 사용이 불가능하다.(static은 공유의 영역, this는 독립의 영역!) 
 * 
 * 생성자
 * - 메서드 이름 클래스랑 동일
 * - 반환타입 존재하면 안됨(명시하면 안됨)
 * - 클래스 생성 시점(new)때만 올 수 있음
 * 
 * 생성자 호출 : this(...)
 * 1. 첫번째 실행 구문으로 와야 한다.
 * 2. 생성자 내에서만 호출이 가능하다.
 * 
 * 디폴트 생성자
 * - 클래스내에 명시적으로 생성자가 정의되어 있지 않은 경우 컴파일러가 자동 추가하는 생성자
 * - 형태 : 클래스접근제한자 클래스명() {}
 */

//static 없으면 instance 메서드
public class Member {
	private String id;
	private String name;
	private String email;
	
	// 이렇게 똑같은 이름의 메서드 사용하다록 = 오버로딩, 이름은 같은데 매개변수의 개수 or 타입이 다를 때 (접근제한자, 반환타입 이런거 상관 없음!)
	public Member() {
		// 오버로딩 개념을 위한거고 메서드 기능은 하나로! 아래꺼 사용해서!
		/*
		this.id = "No ID";
		this.email = "No Email";
		this.name = "No Name";
		*/
		
		//이게 this 생성자 호출
		this("No Id", "No Email", "No Name"); //그냥 Member() 이러면 생성자 new때만 가능해서 에러나고 new Member()해버리면 이쪽에서만 써서 쓸모없어짐
		System.out.println("this 생성자 호출은 가장 위쪽에 위치한다!!(+생성자 안쪽에서만 호출가능) 그래서 이 코드 위로 올리면 에러남");
	}
	//생성자
	public Member(String id, String email, String name) {
		this.id = id;
		this.email = email;
		this.name = name;
	}
	
	// setter
	// 이름 규칙 : set변수명
	// 파라미터 : 변수에 설정할 값
	// 반환타입 : void
	public void setId(/* Member this, */String id){
		// 값에 대한 체크 여기서 하면 됨
		
		// this 현재 실행중인 instance 메서드의 자신, 히든변수로 컴파일러가 자동으로 추가해줌
		this.id = id;
	}
	
	// getter
	// 이름 규칙 : get변수명
	// 파라미터 : 없음
	// 반환타입 : 멤버변수와 같은 타입
	public String getId() {
		return this.id;
	}
	
	// 이클립스서 만드는거 제공해줌 
	// 이클립스서 제공해주는것들은 밖에서 많이 사용하는 거라 보면 됨
	// alt + shift + s, r
	// tip] 이런 기능들 쓰려거든 자신이 짤 줄 알고 사용하는게 좋대
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}	
}
```

